\documentclass{jfp}
% "nolinenum" class option is used to disable the line numbers.

\usepackage{graphicx}
\usepackage{amssymb}
 \usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{latex/agda}
%\usepackage{biblatex}
% \usepackage{unicode-math}
% \setmathfont{XITS Math}
% \setmathfont{XITSMath-Regular}
% [    Extension = .otf,
%       BoldFont = XITSMath-Bold,
% ]

\usepackage{newunicodechar}
\newunicodechar{λ}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{σ}{\ensuremath{\mathnormal\sigma}}
\newunicodechar{π}{\ensuremath{\mathnormal\pi}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{∷}{\ensuremath{::}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{ᴸ}{\ensuremath{^L}}
\newunicodechar{ⱽ}{\ensuremath{^V}}
\newunicodechar{⟧}{\ensuremath{\rrbracket}}
\newunicodechar{⟦}{\ensuremath{\llbracket}}
\newunicodechar{⊤}{\ensuremath{\top}}
\newunicodechar{₁}{\ensuremath{_1}}
\newunicodechar{₂}{\ensuremath{_2}}
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{₀}{\ensuremath{_0}}
\newunicodechar{′}{\ensuremath{'}}
\newunicodechar{ᴬ}{\ensuremath{^A}}
\newunicodechar{∘}{\ensuremath{\circ}}
\newcommand\Nat{ℕ}

\newcommand{\xn}{x_1,\dots,x_n }

\input{jfpmacros}

\newunicodechar{∎}{\ensuremath{\mathnormal\blacksquare}}


\begin{document}

\journaltitle{JFP}
\cpr{Cambridge University Press}
\doival{10.1017/xxxxx}

% \lefttitle{\LaTeX\ Supplement}
% \righttitle{Journal of Functional Programming}

\totalpg{\pageref{lastpage01}}
\jnlDoiYr{2022}

\title{Functional Pearl:\\ Variations on Primitive Recursion}

\begin{authgrp}
  \author{Maximilian Hertenstein}
  \author{Peter Thiemann}
\affiliation{University of Freiburg\\
        (\email{\{mh,thiemann\}@informatik.uni-freiburg.de})}
\end{authgrp}

%\received{20 March 1995; revised 30 September 1998}

\begin{abstract}
Primitive recursive functions are a class of computable total
functions on natural numbers. While they are a standard topic in any
class on computability, it is less well known that primitive recursive
functions generalize in several dimensions. One dimension generalizes
to words, terms, and many-sorted algebras. Another dimension
generalizes to vector-valued functions. A third dimension adds
higher-order functions to obtain System-T and (even more general) STLC
with inductive types. 

We exhibit executable definitions of several classes of primitive
recursive functions and give embeddings from each class into the more
general class. STLC with inductive types is shown to be the most
general language in this class of definitions. All definitions and
embeddings are given in Agda and proved correct.
\end{abstract}
\begin{keywords}
primitive recursion, system-T, inductive types, algebras
\end{keywords}

\maketitle[F]

\section{Introduction}
\label{sec:introduction}

Primitive recursive functions are a standard topic in any class on
computability. 



These functions are a model for computable functions for which an upper bound of the runtime can be specifyed . Particulary they are total.
They are as powerful as  \emph{Loop-Programms}  \cite{loopsRitchie} for which the same can be stated.

The primitiv recursive functions are a proper subset of the  total recursive functions. An example of a function, that is recursive but not primitiv recursiv, is the \emph{Ackermannfunction} \cite{szasz1991machine}.

In the definiton of recursive functions, there is a aditional construct called $\mu$\emph{-Operator}, that can be used to define partial functions.

Recursive functions are as powerful as the untyped lambda calculus and touring-machines \cite{threeModels} \cite[92-94]{ziegler2017godelsche}.

Although  only a few constructors can be used to define primitiv recursive functions, it is possible to define the basic arithmetic functions and also interesting functions like  \emph{nthPrime} with these consturctors.



Usually primitiv recursive functions are defined as a subset of $Fun(\mathbb{N}^n, \mathbb{N})$ definiert. If bigger domains and codomains are used, it is possible to define functions like the ackermann function. Interestingly these functions are still total \cite{DBLP:journals/corr/Widemann16} 


Here is a typical textbook definition\cite{martin2019logik} \cite{wiki:Primitive_recursive_function} :


The primitive recursive functions is the smallest family PR of functions
from ${ℕ}^n$  to ${ℕ}$, for $n\in {ℕ}$, that contains the following
basic functions:
\begin{itemize}
\item for all $n\in {ℕ}$ the $n$-ary constant zero function
  \begin{align*}
	Z^n  &\colon \mathbb{N}^n \rightarrow \mathbb{N}  &
	Z^n    (\xn) &= 0  
  \end{align*}
\item the successor function
  \begin{align*}
	S &\colon \mathbb{N} \rightarrow \mathbb{N} &
	S  (x)  &=  x + 1
  \end{align*}
\item for all $n\in {ℕ}$ and $1\le i\le n$ the $n$-ary projection on
  the $i$-th argument
\begin{align*}
	\pi^{n}_{i} &\colon \mathbb{N}^n \rightarrow \mathbb{N} &
	\pi^{n}_{i}  (x_1,\dots,x_i,\dots,x_n)  &= x_i
\end{align*}
\end{itemize}
PR is closed unter the operations \emph{composition} and \emph{primitive recursion}.
\begin{description}
\item[Composition] 
If $f$ is a primitive recursive function with arity $m \in {ℕ}$ and $g_1,
\dots, g_m$ are primitive recursive functions with arity $n$ then the
composition of $f$ and $g_1, \dots, g_m$ is an $n$-ary primitive recursive function
$h := C (h,(g_1,\dots, g_m)) \colon \mathbb{N}^n \rightarrow \mathbb{N} $ defined by
\begin{align*}
	h  (\xn)  &= f (g_1(\xn),\dots,g_m(\xn)) \\
\end{align*}

\item[Primitive recursion] 
If $g$ and $h$ are primitve recursive functions with aritys $n$ and
$n+2$ then $f := P (g,h)$ is a primitive recursive function of arity $n+1$ that is defined as follows.
\begin{align*}
	f&\colon \mathbb{N}^{n+1} \rightarrow \mathbb{N} \\
	f  (0,\xn)  &= g (\xn) \\
	f  (y + 1,\xn) &= h(  f(y,\xn),y,\xn)
\end{align*}

\end{description}

 

In programming languages terminology, primitive
recursive functions are given by a domain-specific language that
defines functions of type ${ℕ}^n \to {ℕ}$ in a pointfree
style. Moreover, the boundary between syntax and semantics is not
clear.

The following Agda definition formalizes syntax and semantics of pr
functions precisely (and strictly separated).
\input{latex/PR-Nat}

It is a good exercise to remind ourselves that the standard arithmetic
functions are pr defineable and correspond to their definitions in
Agda. Here is the easy case for addition; the online supplement
considers further operations. 
\input{latex/PR-Nat-Example}
The function \AgdaFunction{addP} is defined by primitive recursion, which
decomposes the first argument. The $g$-function is just the identity;
the $h$-function composes the successor with inductive result.
The equivalence proof is a
straightforward induction because the structure of the definitions
matches.

\section{From numbers to words, terms, and many-sorted algebras}
\label{sec:from-numbers-words}

While primitive recursion on natural numbers is well-known, it is less
well-known that primitive recursion can be defined on more general
algebras. In particular, we consider words over an alphabet $A$, terms
over a ranked alphabet $A$, and many-sorted terms. 

\subsection{Primitive recursion on words}
\label{sec:prim-recurs-words}

The textbook definition of $A^*$, the sets of words over an alphabet $A$ goes like this:
\begin{align*}
  A^0 &= \{ \varepsilon \} & A^{n+1} &= A \times A^n & A^* &=
  \bigcup^{n \in ℕ} A^n
\end{align*}
This definition slightly obscures the underlying algebraic structure, a list of
elements of $A$, which is better described as a fixed point:
$A^*\cong \ATop + A \times A^*$ where $\ATop$ is a one-element type.
Compared with the natural numbers, we can say that a word is
constructed from one nullary constructor, typically called
$\varepsilon$, and then a successor, $\sigma_a$, for each symbol $a\in A$.

Rosza Peter~\cite{xxx} defines primitive recursion on words
accordingly. The $n$-ary $0$-function becomes the $n$-ary
$\varepsilon$-function; the single successor $\sigma$ generalizes to a
family of successors $\sigma_a$; projection and composition do not
change; and for primitive recursion we have a $g$-function to handle the
case for $\varepsilon$ and a family of functions $h_a$ to handle the
case for $\sigma_a$. The arities of the functions are the same as before.
\input{latex/PR-Words}
Natural numbers arise as the special case where the alphabet $A$ is a
one-element set: we can prove that $\Nat \cong \text{\AList\ATop}$. Hence, we
can soundly embed pr on natural numbers into pr on words over an
alphabet by instantiating $A$ to $\ATop$.
\input{latex/NatsToWords}

\subsection{Primitive recursion on terms}
\label{sec:prim-recurs-trees}

To move from words to terms requires generalizing alphabets to
\emph{ranked alphabets}. A ranked alphabet consists of a set of
symbols and a ranking function that assigns each symbol a rank (arity) in \Nat.
\input{latex/PR-Trees}
Again, we can establish pr over words as a special case of pr on
terms. Given an alphabet $A$ we define a ranked alphabet with symbols
$A + \ATop \cong \text{\AMaybe{A}}$ and ranks defined such that the element
from $\ATop$ has arity $0$ and all other element from $A$ have arity
$1$. This mapping of types also determines the embedding of values.
\input{latex/WordsToTrees}

\subsection{Primitive recursion on many-sorted terms}
\label{sec:prim-recurs-sort}

A close look at the definition of the datatype \ATerm{R} shows that
terms are akin to singly recursive algebraic datatypes. To see that,
imagine that we specialize the single constructor {\Acon} with respect
to its first argument $a\in{}$\Asymbols{R}. This specialization yields
an algebraic datatype with constructors \Acon$_a$, one for each
element of \Asymbols{R}. The arity of such a constructor is given by
the rank of $a$.

Many-sorted terms are closely related to \emph{mutually recursive} algebraic
datatypes. To define many-sorted terms, we start with a set of sorts
$S$. The cardinality of $S$ determines the number of mutually
recursive types. 
An $S$-sorted alphabet consists of a set of symbols and a sorting
function that assigns each symbol an arity of the form $(w, s)$ where
$w \in S^*$ and $s \in S$. This definition translates roughly to:
every constructor has a simple first-order type.
\input{latex/PR-HTrees}

\section{Vector-valued primitive recursion}
\label{sec:vect-valu-prim}

\section{System-T and beyond}
\label{sec:system-t-beyond}

In this section we define a version of System-T that only allows first order arguments and show that this version is exactly as powerful as primitve recursive functions on natural numbers.

The first index of this datatype is the size of the context, the second one is the number of arguments. 
\input{latex/System-T0}
\defSTZero

To evaluate the iterator of this language we define paramorphisms for natural numbers. 

\input{latex/EvalPConstructor}
\para
\evalST


First we define functions that return closed terms, that hat have a similiar semantic as the constructors of the primitive recursion. We combine them in the following function.

\input{latex/PR-SystemT0-Embedding}
\prToStSig

Than we proove, that these terms work as excpected.
Again we combine these proofs in this theorem: 
\embedPRSTSoundSig


We give a detailed example for the projection and sketch the proof for the general composition.

The following functions and lemmas are useful in all parts of this proof.

\prepLambdas

\input{latex/VecProperties}

Here \AgdaFunction{++r} is takes two vectors, reverses the first and appends the second.
\appendR

This shows that if we evaluate a closed term generated with \AgdaFunction{prepLambdas}, we have to evaluate the wrapped expression with the reversed arguments as the context.

This implies that we also need to take the opposite of the index of projection as the DeBruijn-Index of the term, that we use to mimic the projection.

\mkProj

\lookupOpRev

We can use this in the prove of our theorem.
\prToStProj
\embedPRSTSoundProj

It is straight forward to define the remaing functions in Agda, but to get a understanding of the idea of this proof it is enough to know, what we want to express with them. The terms that we use to express the zero functions, composition and primitive recursion are enumerated below.

\begin{enumerate}
	\item $$\lambda x_1 \dots x_{n} \rightarrow 0 $$
	\item $$\lambda \xn \rightarrow  f \ (g_1 \ \xn) \dots (g_m \ \xn) $$
	\item $$\lambda x_1 \dots x_{n+1} \rightarrow \mathtt{PRecTC} \ (\lambda a b . h \, a \, b \, x_2 \dots x_{n+1}) \ (g \, x_2 \dots x_{n+1}) \ x_1 $$
\end{enumerate}


It is a well known fact, that some fuctions that can be expressed with System-T, like the Ackermann function, are not primitiv recursive. 

Because the implementation above is restricted to first-order types. We can show that for every term of this language, there is a primitv recursiv function with the same semantic. 

%The function that generates the term that mimics the composition is called \AgdaFunction{generalComp}. The following theorem states that the semantic of the returning function is similiar  than the composition operator.
%
%\evalGeneralComp




\section{Conclusions}
\label{sec:conclusions}

\bibliographystyle{jfplike}
\bibliography{jfprefs}

\label{lastpage01}

\end{document}
