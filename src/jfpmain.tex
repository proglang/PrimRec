\documentclass{jfp}
% "nolinenum" class option is used to disable the line numbers.

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{latex/agda}
% \usepackage{unicode-math}
% \setmathfont{XITS Math}
% \setmathfont{XITSMath-Regular}
% [    Extension = .otf,
%       BoldFont = XITSMath-Bold,
% ]

\usepackage{newunicodechar}
\newunicodechar{λ}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{σ}{\ensuremath{\mathnormal\sigma}}
\newunicodechar{π}{\ensuremath{\mathnormal\pi}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{∷}{\ensuremath{::}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{ᴸ}{\ensuremath{^L}}
\newunicodechar{ⱽ}{\ensuremath{^V}}
\newunicodechar{⟧}{\ensuremath{\rrbracket}}
\newunicodechar{⟦}{\ensuremath{\llbracket}}
\newunicodechar{⊤}{\ensuremath{\top}}
\newunicodechar{₁}{\ensuremath{_1}}
\newunicodechar{∈}{\ensuremath{\in}}

\newcommand\Nat{ℕ}

\input{jfpmacros}

\begin{document}

\journaltitle{JFP}
\cpr{Cambridge University Press}
\doival{10.1017/xxxxx}

% \lefttitle{\LaTeX\ Supplement}
% \righttitle{Journal of Functional Programming}

\totalpg{\pageref{lastpage01}}
\jnlDoiYr{2022}

\title{Functional Pearl:\\ Variations on Primitive Recursion}

\begin{authgrp}
  \author{Maximilian Hertenstein}
  \author{Peter Thiemann}
\affiliation{University of Freiburg\\
        (\email{\{mh,thiemann\}@informatik.uni-freiburg.de})}
\end{authgrp}

%\received{20 March 1995; revised 30 September 1998}

\begin{abstract}
Primitive recursive functions are a class of computable total
functions on natural numbers. While they are a standard topic in any
class on computability, it is less well known that primitive recursive
functions generalize in several dimensions. One dimension generalizes
to words, terms, and many-sorted algebras. Another dimension
generalizes to vector-valued functions. A third dimension adds
higher-order functions to obtain System-T and (even more general) STLC
with inductive types. 

We exhibit executable definitions of several classes of primitive
recursive functions and give embeddings from each class into the more
general class. STLC with inductive types is shown to be the most
general language in this class of definitions. All definitions and
embeddings are given in Agda and proved correct.
\end{abstract}
\begin{keywords}
primitive recursion, system-T, inductive types, algebras
\end{keywords}

\maketitle[F]

\section{Introduction}
\label{sec:introduction}

Primitive recursive functions are a standard topic in any class on
computability. 
Here is a typical textbook definition:

FILL IN

In programming languages terminology, primitive
recursive functions are given as a domain-specific language that
defines defines functions of type ${ℕ}^n \to {ℕ}$ in a pointfree
style. As an additional bonus, the following Agda definition separates syntax and semantics.
\input{latex/PR-Nat}

It is a good exercise to remind ourselves that the standard arithmetic
functions are pr defineable and correspond to their definitions in
Agda. Here is the easy case for addition; the online supplement
considers further operations. 
\input{latex/PR-Nat-Example}
The equivalence proof is a
straightforward induction because the structure of the definitions
matches. \AgdaFunction{addP} is defined by primitive recursion, which
decomposes the first argument. The $g$-function is just the identity;
the $h$-function composes the successor with inductive result.

\section{From numbers to words, terms, and many-sorted algebras}
\label{sec:from-numbers-words}

While primitive recursion on natural numbers is well-known, it is less
well-known that primitive recursion can be defined on more general
algebras. In particular, we consider words over an alphabet $A$, terms
over a ranked alphabet $A$, and many-sorted terms. 

\subsection{Primitive recursion on words}
\label{sec:prim-recurs-words}

The textbook definition of $A^*$, the sets of words over an alphabet $A$ goes like this:
\begin{align*}
  A^0 &= \{ \varepsilon \} & A^{n+1} &= A \times A^n & A^* &=
  \bigcup^{n \in ℕ} A^n
\end{align*}
This definition slightly obscures the underlying algebraic structure, a list of
elements of $A$, which is better described as a fixed point:
$A^*\cong \ATop + A \times A^*$ where $\ATop$ is a one-element type.
Compared with the natural numbers, we can say that a word is
constructed from one nullary constructor, typically called
$\varepsilon$, and then a successor, $\sigma_a$, for each symbol $a\in A$.

Rosza Peter~\cite{xxx} defines primitive recursion on words
accordingly. The $n$-ary $0$-function becomes the $n$-ary
$\varepsilon$-function; the single successor $\sigma$ generalizes to a
family of successors $\sigma_a$; projection and composition do not
change; and for primitive recursion we have a $g$-function to handle the
case for $\varepsilon$ and a family of functions $h_a$ to handle the
case for $\sigma_a$. The arities of the functions are the same as before.
\input{latex/PR-Words}
Natural numbers arise as the special case where the alphabet $A$ is a
one-element set: we can prove that $\Nat \cong \text{\AList\ATop}$. Hence, we
can soundly embed pr on natural numbers into pr on words over an
alphabet by instantiating $A$ to $\ATop$.
\input{latex/NatsToWords}

\subsection{Primitive recursion on terms}
\label{sec:prim-recurs-trees}

To move from words to terms requires generalizing alphabets to
\emph{ranked alphabets}. A ranked alphabet consists of a set and a
ranking function that assigns each symbol a rank (arity) in \Nat.
\input{latex/PR-Trees}
Again, we can establish pr over words as a special case of pr on
terms. Given an alphabet $A$ we define a ranked alphabet with symbols
$A + \ATop \cong \text{\AMaybe{A}}$ and ranks defined such that the element
from $\ATop$ has arity $0$ and all other element from $A$ have arity
$1$. This mapping of types also determines the embedding of values.
\input{latex/WordsToTrees}

\section{Vector-valued primitive recursion}
\label{sec:vect-valu-prim}

\section{System-T and beyond}
\label{sec:system-t-beyond}

\section{Conclusions}
\label{sec:conclusions}

\bibliographystyle{jfplike}
\bibliography{jfprefs}

\label{lastpage01}

\end{document}
