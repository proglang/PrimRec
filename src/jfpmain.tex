\documentclass{jfp}
% "nolinenum" class option is used to disable the line numbers.

\usepackage{graphicx}
\usepackage{amssymb}
 \usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{latex/agda}
%\usepackage{biblatex}
% \usepackage{unicode-math}
% \setmathfont{XITS Math}
% \setmathfont{XITSMath-Regular}
% [    Extension = .otf,
%       BoldFont = XITSMath-Bold,
% ]

\usepackage{newunicodechar}
\newunicodechar{λ}{\ensuremath{\mathnormal\lambda}}
\newunicodechar{σ}{\ensuremath{\mathnormal\sigma}}
\newunicodechar{π}{\ensuremath{\mathnormal\pi}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{∷}{\ensuremath{::}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{ᴸ}{\ensuremath{^L}}
\newunicodechar{ᴿ}{\ensuremath{^R}}
\newunicodechar{ʳ}{\ensuremath{^r}}
\newunicodechar{ⱽ}{\ensuremath{^V}}
\newunicodechar{⟧}{\ensuremath{\rrbracket}}
\newunicodechar{⟦}{\ensuremath{\llbracket}}
\newunicodechar{⊤}{\ensuremath{\top}}
\newunicodechar{₁}{\ensuremath{_1}}
\newunicodechar{₂}{\ensuremath{_2}}
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{₀}{\ensuremath{_0}}
\newunicodechar{′}{\ensuremath{'}}
\newunicodechar{ᴬ}{\ensuremath{^A}}
\newunicodechar{∘}{\ensuremath{\circ}}
\newcommand\Nat{ℕ}

\newcommand{\xn}{x_1,\dots,x_n }
\newcommand{\xs}[1]{x_1\dots x_{#1}}

\input{jfpmacros}

\newunicodechar{∎}{\ensuremath{\mathnormal\blacksquare}}


\begin{document}

\journaltitle{JFP}
\cpr{Cambridge University Press}
\doival{10.1017/xxxxx}

% \lefttitle{\LaTeX\ Supplement}
% \righttitle{Journal of Functional Programming}

\totalpg{\pageref{lastpage01}}
\jnlDoiYr{2022}

\title{Functional Pearl:\\ Variations on Primitive Recursion}

\begin{authgrp}
  \author{Maximilian Hertenstein}
  \author{Peter Thiemann}
\affiliation{University of Freiburg\\
        (\email{\{mh,thiemann\}@informatik.uni-freiburg.de})}
\end{authgrp}

%\received{20 March 1995; revised 30 September 1998}

\begin{abstract}
Primitive recursive functions are a class of computable total
functions on natural numbers. While they are a standard topic in any
class on computability, it is less well known that primitive recursive
functions generalize in several dimensions. One dimension generalizes
to words, terms, and many-sorted algebras. Another dimension
generalizes to vector-valued functions. A third dimension adds
higher-order functions to obtain System-T and (even more general) STLC
with inductive types. 

We exhibit executable definitions of several classes of primitive
recursive functions and give embeddings from each class into the more
general class. STLC with inductive types is shown to be the most
general language in this class of definitions. All definitions and
embeddings are given in Agda and proved correct.
\end{abstract}
\begin{keywords}
primitive recursion, system-T, inductive types, algebras
\end{keywords}

\maketitle[F]

\section{Introduction}
\label{sec:introduction}

Primitive recursive functions are a standard topic in any class on
computability. 



These functions are a model for computable functions for which an upper bound of the runtime can be specified . Particularly they are total.
They are as powerful as  \emph{Loop-Programms}  \cite{loopsRitchie} for which the same can be stated.

The primitive recursive functions are a proper subset of the  total recursive functions. An example of a function, that is recursive but not primitive recursive, is the \emph{Ackermann function} \cite{szasz1991machine}.

In the definition of recursive functions, there is a additional construct called $\mu$\emph{-Operator}, that can be used to define partial functions.

Recursive functions are as powerful as the untyped lambda calculus and touring-machines \cite{threeModels} \cite[92-94]{ziegler2017godelsche}.

Although  only a few constructors can be used to define primitive recursive functions, it is possible to define the basic arithmetic functions and also interesting functions like  \emph{nthPrime} with these constructors.



Usually primitiv recursive functions are defined as a subset of $Fun(\mathbb{N}^n, \mathbb{N})$. If bigger domains and codomains are used, it is possible to define functions like the Ackermann function. Interestingly these functions are still total \cite{DBLP:journals/corr/Widemann16} 


Here is a typical textbook definition\cite{martin2019logik} \cite{wiki:Primitive_recursive_function} :


The primitive recursive functions is the smallest family PR of functions
from ${ℕ}^n$  to ${ℕ}$, for $n\in {ℕ}$, that contains the following
basic functions:
\begin{itemize}
\item for all $n\in {ℕ}$ the $n$-ary constant zero function
  \begin{align*}
	Z^n  &\colon \mathbb{N}^n \rightarrow \mathbb{N}  &
	Z^n    (\xn) &= 0  
  \end{align*}
\item the successor function
  \begin{align*}
	S &\colon \mathbb{N} \rightarrow \mathbb{N} &
	S  (x)  &=  x + 1
  \end{align*}
\item for all $n\in {ℕ}$ and $1\le i\le n$ the $n$-ary projection on
  the $i$-th argument
\begin{align*}
	\pi^{n}_{i} &\colon \mathbb{N}^n \rightarrow \mathbb{N} &
	\pi^{n}_{i}  (x_1,\dots,x_i,\dots,x_n)  &= x_i
\end{align*}
\end{itemize}
PR is closed under the operations \emph{composition} and \emph{primitive recursion}.
\begin{description}
\item[Composition] 
If $f$ is a primitive recursive function with arity $m \in {ℕ}$ and $g_1,
\dots, g_m$ are primitive recursive functions with arity $n$ then the
composition of $f$ and $g_1, \dots, g_m$ is an $n$-ary primitive recursive function
$h := C (h,(g_1,\dots, g_m)) \colon \mathbb{N}^n \rightarrow \mathbb{N} $ defined by
\begin{align*}
	h  (\xn)  &= f (g_1(\xn),\dots,g_m(\xn)) \\
\end{align*}

\item[Primitive recursion] 
If $g$ and $h$ are primitive recursive functions with aritys $n$ and
$n+2$ then $f := P (g,h)$ is a primitive recursive function of arity $n+1$ that is defined as follows.
\begin{align*}
	f&\colon \mathbb{N}^{n+1} \rightarrow \mathbb{N} \\
	f  (0,\xn)  &= g (\xn) \\
	f  (y + 1,\xn) &= h(  f(y,\xn),y,\xn)
\end{align*}

\end{description}

 

In programming languages terminology, primitive
recursive functions are given by a domain-specific language that
defines functions of type ${ℕ}^n \to {ℕ}$ in a pointfree
style. Moreover, the boundary between syntax and semantics is not
clear.

The following Agda definition formalizes syntax and semantics of pr
functions precisely (and strictly separated).
\input{latex/PR-Nat}

It is a good exercise to remind ourselves that the standard arithmetic
functions are pr defineable and correspond to their definitions in
Agda. Here is the easy case for addition; the online supplement
considers further operations. 
\input{latex/PR-Nat-Example}
The function \AgdaFunction{addP} is defined by primitive recursion, which
decomposes the first argument. The $g$-function is just the identity;
the $h$-function composes the successor with inductive result.
The equivalence proof is a
straightforward induction because the structure of the definitions
matches.

\section{From numbers to words, terms, and many-sorted algebras}
\label{sec:from-numbers-words}

While primitive recursion on natural numbers is well-known, it is less
well-known that primitive recursion can be defined on more general
algebras. In particular, we consider words over an alphabet $A$, terms
over a ranked alphabet $A$, and many-sorted terms. 

\subsection{Primitive recursion on words}
\label{sec:prim-recurs-words}

The textbook definition of $A^*$, the sets of words over an alphabet $A$ goes like this:
\begin{align*}
  A^0 &= \{ \varepsilon \} & A^{n+1} &= A \times A^n & A^* &=
  \bigcup^{n \in ℕ} A^n
\end{align*}
This definition slightly obscures the underlying algebraic structure, a list of
elements of $A$, which is better described as a fixed point:
$A^*\cong \ATop + A \times A^*$ where $\ATop$ is a one-element type.
Compared with the natural numbers, we can say that a word is
constructed from one nullary constructor, typically called
$\varepsilon$, and then a successor, $\sigma_a$, for each symbol $a\in A$.

Rosza Peter~\cite{peter35:_uber_zusam_begrif_funkt} defines primitive recursion on words
accordingly. The $n$-ary $0$-function becomes the $n$-ary
$\varepsilon$-function; the single successor $\sigma$ generalizes to a
family of successors $\sigma_a$; projection and composition do not
change; and for primitive recursion we have a $g$-function to handle the
case for $\varepsilon$ and a family of functions $h_a$ to handle the
case for $\sigma_a$. The arities of the functions are the same as before.
\input{latex/PR-Words}
Natural numbers arise as the special case where the alphabet $A$ is a
one-element set: we can prove that $\Nat \cong \text{\AList\ATop}$. Hence, we
can soundly embed pr on natural numbers into pr on words over an
alphabet by instantiating $A$ to $\ATop$.
\input{latex/NatsToWords}

\subsection{Primitive recursion on terms}
\label{sec:prim-recurs-trees}

To move from words to terms requires generalizing alphabets to
\emph{ranked alphabets}. A ranked alphabet consists of a set of
symbols and a ranking function that assigns each symbol a rank (arity) in \Nat.
\input{latex/PR-Trees}
Again, we can establish pr over words as a special case of pr on
terms. Given an alphabet $A$ we define a ranked alphabet with symbols
$A + \ATop \cong \text{\AMaybe{A}}$ and ranks defined such that the element
from $\ATop$ has arity $0$ and all other element from $A$ have arity
$1$. This mapping of types also determines the embedding of values.
\input{latex/WordsToTrees}

\subsection{Primitive recursion on many-sorted terms}
\label{sec:prim-recurs-sort}

A close look at the definition of the datatype \ATerm{R} shows that
terms are akin to singly recursive algebraic datatypes. To see that,
imagine that we specialize the single constructor {\Acon} with respect
to its first argument $a\in{}$\Asymbols{R}. This specialization yields
an algebraic datatype with constructors \Acon$_a$, one for each
element of \Asymbols{R}. The arity of such a constructor is given by
the rank of $a$.

Many-sorted terms are closely related to \emph{mutually recursive} algebraic
datatypes. To define many-sorted terms, we start with a set of sorts
$S$. The cardinality of $S$ determines the number of mutually
recursive types. 
An $S$-sorted alphabet consists of a set of symbols and a sorting
function that assigns each symbol an arity of the form $(w, s)$ where
$w \in S^*$ and $s \in S$. This definition translates roughly to:
every constructor has a simple first-order type.
\input{latex/PR-HTrees}

\section{Vector-valued primitive recursion}
\label{sec:vect-valu-prim}

\section{System~T and beyond}
\label{sec:system-t-beyond}

Gödel's System~T comprises the simply-typed lambda calculus extended
with natural numbers and a primitive recursor. While this calculus
enjoys strong normalisation, it is nevertheless possible to encode the
Ackermann function, as well as other fast-growing functions (see
\cite{DBLP:books/cu/Ha2016,DBLP:journals/corr/Widemann16}), which are known not 
to be primitive recursive. These definitions are possible because
System~T admits primitive recursive definitions at higher-order types.

If we restrict System~T to first-order functions, then we can show
that this version is equally expressive as primitive recursive
functions on natural numbers. 

To define this restriction, we use an intrinsic representation of
lambda terms as a datatype \AExp{n}{m} where first index is the size
of the context (number of free variables) and the second one is the
number of arguments. All variables and arguments will have type \ANat.
\input{latex/System-T0}
\defSTZero

To evaluate the iterator of this language we define paramorphisms for
natural numbers \cite{DBLP:conf/fpca/MeijerFP91}. 

\input{latex/EvalPConstructor}
\para
\evalST


To prove equivalence with standard primitive recursion, we start by defining a
function that returns closed lambda terms and prove that their
semantics matches the corresponding constructors of primitive recursion.

\input{latex/PR-SystemT0-Embedding}
\prToStSig
\embedPRSTSoundSig


We give a detailed explanation for the projection and sketch the ideas for the other constructors.

The following functions and lemmas are useful in all parts of this
proof. They relate the evaluation of a term and the same term weakened
under some binders.

\prepLambdas

\input{latex/VecProperties}


These lemmas prove that evaluation of a closed expression generated with
\AgdaFunction{prepLambdas} corresponds to evaluation of the wrapped
expression with the reversed arguments as the context.\footnote{
The function \AgdaFunction{++r} takes two vectors, reverses the first,
and prepends it to the second. We write $^R$ for a function that
reverses a vector using \AgdaFunction{++r}.
% \appendR 
}

Getting back to the case of projection, we need to take the opposite ($n - i$) of the index of a
projection as the deBruijn index in the term used to mimic the projection.

\mkProj

\lookupOpRev

It remains to state the corresponding lines in the definition of the
translation and the proof of the embedding:
\prToStProj
\embedPRSTSoundProj

It is not difficult to define the remaining cases in Agda, so we just
give a high-level overview of the expressions we use to represent the zero functions, composition, and primitive recursion.
\begin{align*}
  \text{$n$-ary zero: } & \lambda \xs{n} \rightarrow 0 \\
  \text{composition: } & \lambda \xs{n} \rightarrow  f \ (g_1 \ \xs{n})
                        \dots (g_m \ \xs{n}) \\
  \text{primitive recursion: } & \lambda \xs{n+1} \rightarrow \mathtt{PRecTC} \ (\lambda a b . h \, a \, b \, x_2 \dots x_{n+1}) \ (g \, x_2 \dots x_{n+1}) \ x_1 
\end{align*}


It is a well known fact, that some functions that can be expressed with System-T, like the Ackermann function, are not primitive recursive. 

Because the implementation above is restricted to first-order types. We can show that for every term of this language, there is a primitive recursive function with the same semantic. 

First we have to define a function, that maps expressions in the restricted System-T to primitive recursive functions.
We can't restrict these function to closed terms, because than that function could not be recursively called on the body of a lambda expression, that is defined in a context of size one.  


So we have to define and more general embedding and soundness-theorem, in which we add the number of arguments and the size of the context, to get the arity of the primitive recursive function.


\input{latex/System-T0-PR-Embedding}

\sTtoPRSignature

\sTtoPRSoundSig

The idea behind these definitions is that every element of \AgdaDatatype{Exp n m} can be transformed to a closed term with type \AgdaDatatype{Exp 0 (n + m)} by wrapping the term behind \AgdaBound{n} binders. By the lemma \AgdaFunction{prepLambdasEval}, we know that evaluating this  expression on reverse-concatenation of the context and the arguments gives the same result as evaluating the inner expression with the context and the arguments.
So \AgdaFunction{sTtoPR} map an expression of System-T0 to 
a primitive recursive function, that has the same semantic than the an expression, that was made closed with  \AgdaFunction{prepLambdas}
%%%now about the semantic of this new term. 

When we define the function \AgdaFunction{sTtoPR} we have to consider that in the soundness-theorem above, for an expression the corresponding primitive recursive function
doesn't get evaluated just with the arguments of this expression but with the reverse-concatenation of the context and the arguments.
%
For example the successor function in System-T0 can be evaluated with an context of an arbitrary size $n$ and one argument. When we map this function to a primitive recursive function, we can evaluate it with $n + 1$ arguments. Only the last of these arguments is needed to compute the result, so we have to ignore all other arguments.
\sTtoPRSuc
That is done with a projection that returns the last argument of the input of the primitive recursive function, which is the first element that was not in context of the expression in System-T0.
\sTtoPRSoundSuc

Then this part of the proof can be reduced to a simple theorem about vectors.
\lookupFromN

The translation of the reaming constructors is either very simply or very technical. So we just give the example of the \AgdaFunction{App} Constructor.
\begin{itemize}
	\item If f is an element of \AgdaDatatype{Exp (n + 1) m} and x is an element \AgdaDatatype{Exp 0 m} then the App Constructor can be expressed like this. A prime means that this is a translated sub expression.
	
	$$ (App \ f \ x) \ \rightarrow \ C \ f' \ (\pi_{1}\dots\pi_{n}, C \ x' \ (Z_{n}),\pi_{n + 1}\dots\pi_{n + m}  ) $$ 
\end{itemize}

For the translation of \AgdaFunction{App}, \AgdaFunction{Lam} and \AgdaFunction{Var} only \AgdaFunction{C} and \AgdaFunction{π} are needed and vice versa. This means this theorem is not only true for a language with a Nat-Iterator or primitive recursion. 



%The function that generates the term that mimics the composition is called \AgdaFunction{generalComp}. The following theorem states that the semantic of the returning function is similiar  than the composition operator.
%
%\evalGeneralComp




\section{Conclusions}
\label{sec:conclusions}

\bibliographystyle{jfplike}
\bibliography{jfprefs}

\label{lastpage01}

\end{document}
