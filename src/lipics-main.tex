\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

\pdfoutput=1
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\usepackage{stmaryrd}
\usepackage{latex/agda}



\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Primitive Recursion \\ in Bicartesian Closed Categories} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Jane {Open Access}}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Joan R. Public\footnote{Optional footnote, e.g. to mark corresponding author}}{Department of Informatics, Dummy College, [optional: Address], Country}{joanrpublic@dummycollege.org}{[orcid]}{}

\authorrunning{J. Open Access and J.\,R. Public} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Jane Open Access and Joan R. Public} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Dummy keyword} %TODO mandatory; please add comma-separated list of keywords

% \category{} %optional, e.g. invited paper

% \relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

% \acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{unicodeletters}
\input{jfpmacros}

\begin{document}
\newcommand\Nat{\ensuremath{\mathbb{N}}}
\newcommand{\many}[2]{{#1}_0,\dots,{#1}_{#2-1}}
\newcommand{\xs}{\many{x}}
\newcommand{\xn}{\xs{n}}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
  The standard definition of PR-NAT, the system of primitive recursive functions on natural
  numbers, is given in a pointfree style. Generalizations thereof like
  System T or systems with inductive types are mostly embedded in
  typed lambda calculi.

  We present two pointfree languages that generalize primitive
  recursion on natural numbers. PR1-IND defines
  first-order primitive recursive functions on inductive types in a
  distributive
  category. PR-IND extends PR1-IND to higher-order functions in a
  bicartesian closed category.

  We give the first complete, mechanized semantic description of
  PR1-IND and PR-IND in Agda, embeddings from PR-NAT to PR1-IND and
  PR1-IND to PR-IND, and an elementary proof of the folklore theorem
  that every bicartesian closed category is distributive. We cannot
  find a similar elementary proof in published literature.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Primitive recursive functions, PR-NAT, are a class of total computable
functions on natural numbers. They are a standard topic in any
class on computability theory and serve as a stepping stone for
defining general recursive functions
\cite{kleene36:_gener_recur_funct_natur_number}.
It is well known that there are total functions on natural
numbers, which are not primitive recursive. The
Ackermann function \cite{szasz1991machine}, Knuth's uparrow
notation, and Conway's arrow notation are standard examples. However,
these functions are definable in System~T (see
\cite{DBLP:journals/corr/Widemann16} for definitions), which adds higher-order functions to PR-NAT (see
\cite[Chapter 9]{DBLP:books/cu/Ha2016}) and thus defines a larger
class of total computable functions.


The concept of primitive recursion can be generalized in several
dimensions. One dimension is first-order vs.\ higher-order,
corresponding to PR-NAT vs.\ System~T. A second dimension generalizes
to functions over words, terms, and many-sorted algebras. A third
dimension generalizes to vector-valued functions aka LOOP-computable
functions. The second and third dimensions can be subsumed by
situating primitive recursion in a bicartesian category, i.e., a
first-order language with finite product and sum types augmented with
an inductive type, which we call PR1-IND.  Closely related, but
subtly different, languages are discussed in Harper's book
\cite[Chapter 15]{DBLP:books/cu/Ha2016} and in the bananas paper
\cite{DBLP:conf/fpca/MeijerFP91}. 

Adding the higher-order dimension to PR1-IND leads to studying
primitive recursion in a bicartesian closed category, as considered
by Meijer and Hutton \cite{DBLP:conf/fpca/MeijerH95} and which is
implicitly and often unknowingly used by Haskell programmers. Such
categories have all finite products and coproducts (sums) as well as
exponentials. We call this language PR-IND.

We start our work from the observation that the standard definition of
PR-NAT is very close to a categorical description. Taken literally,
primitive recursive functions are defined in a pointfree style by
composing and combining predefined arrows. We define syntax and
semantics of PR-Nat in Agda, give examples, and prove their correctness.

Inspired by this observation, we go on to define PR1-IND in the same
pointfree style. Defining the semantics turns out to be surprisingly
subtle because, unlike Harper's definition \cite[Chapter
15]{DBLP:books/cu/Ha2016}, PR1-IND admits nested inductive types.
Clearly, it should be possible to translate any PR-NAT program into a
semantically equivalent program in PR1-IND, but this attempt reveals
that a bicartesian category is not sufficient for this translation,
but a distributive category is needed. That is, distributivity needs
to be added to our language as a family of axiomatic arrows.

Finally, we extend PR1-IND with exponentials to PR-IND. The definition
of the semantics smoothly extends the one for PR1-IND. As an
additional twist, surprising to the authors who are not category
theorists, the distributivity axiom becomes obsolete as it derivable in
a bicartesian closed category. We give an elementary proof of this
folklore result \cite{https://doi.org/10.48550/arxiv.1406.0961}. 

All definitions, results, and proofs are mechanized using Agda and
publicly available in a GitHub
repository.\footnote{\url{https://github.com/proglang/PrimRec/}
  release 2023-02 corresponds to the submitted paper} 

\section{Primitive recursion on natural numbers}
\label{sec:prim-recurs-natur}
\input{latex/PR-Nat}

Here is a typical textbook definition~\cite{martin2019logik,wiki:Primitive_recursive_function}:


The set of primitive recursive functions is the smallest family PR of functions
from ${ℕ}^n$  to ${ℕ}$, for $n\in {ℕ}$, that contains the following
basic functions:
\begin{itemize}
\item for all $n\in {ℕ}$ the $n$-ary constant zero function
  \begin{align*}
	Z^n  &\colon \mathbb{N}^n \rightarrow \mathbb{N}  &
	Z^n    (\xn) &= 0  
  \end{align*}
\item the successor function
  \begin{align*}
	S &\colon \mathbb{N} \rightarrow \mathbb{N} &
	S  (x)  &=  x + 1
  \end{align*}
\item for all $n\in {ℕ}$ and $0\le i< n$ the $n$-ary projection on
  the $i$-th argument
\begin{align*}
	\pi^{n}_{i} &\colon \mathbb{N}^n \rightarrow \mathbb{N} &
	\pi^{n}_{i}  (x_0,\dots,x_i,\dots,x_{n-1})  &= x_i
\end{align*}
\end{itemize}
PR is closed under the operations \emph{composition} and \emph{primitive recursion}.
\begin{description}
\item[Composition] 
If $f$ is a primitive recursive function with arity $m \in {ℕ}$ and
$\many{g}{m}$ are primitive recursive functions with arity $n$ then
the composition of $f$ and $\many gm$ is an $n$-ary primitive recursive function
$h := C (h,(\many gm)) \colon \mathbb{N}^n \rightarrow \mathbb{N} $ defined by
\begin{align*}
	h  (\xn)  &= f (g_1(\xn),\dots,g_m(\xn)) 
\end{align*}

\item[Primitive recursion] 
If $g$ and $h$ are primitive recursive functions with arities $n$ and
$n+2$ then $f := P (g,h)$ is a primitive recursive function of arity $n+1$ that is defined as follows.
\begin{align*}
	f&\colon \mathbb{N}^{n+1} \rightarrow \mathbb{N} \\
	f  (0,\xn)  &= g (\xn) \\
	f  (y + 1,\xn) &= h(  f(y,\xn),y,\xn)
\end{align*}

\end{description}

Clearly, PR is inductively defined, but unfortunately the boundary
between syntax and semantics is blurred.


In programming languages terminology, primitive
recursive functions are given by a domain-specific language where a
sentence of the language specifies a total function of type ${ℕ}^n \to {ℕ}$
in a pointfree style. The syntax of the language is inductively
defined and consequently its semantics is defined by induction on the
syntax, thus cleanly separating syntax and semantics.

The following Agda definition formalizes syntax and semantics of pr
functions precisely (and strictly separated).
The datatype \APR{n} defines an abstract syntax for $n$-ary primitive recursive functions.
The type \AVec{A}{n} contains vectors of size $n$ with elements of type $A$.
The type \AFin{n} comprises the elements $\{0, 1, \dots, n-1\}$, which
are exactly the valid indices for a vector of type \AVec{A}{n}. 
The function \AgdaFunction{lookup v* i} accesses such a vector at index $i$.

\PRNat

The function \AgdaFunction{eval} maps a pr function to its semantics.
We represent ${ℕ}^n$ by the vector type \AVec{ℕ}n and use the bracket notation for vectors: \Anil, \Aone{x}, \Atwo{x}{y}, etc.

\PRNatEval

The function \AgdaFunction{eval*} can be expressed equivalently as a
map over the vector of functions \AgdaBound{g*}, alas the termination
checker does not accept this definition.  


It is a good exercise to remind ourselves that the standard arithmetic
functions are pr defineable and correspond to their definitions in
Agda. Here is the easy case for addition; the online supplement
considers further operations. 
\input{latex/PR-Nat-Example}
\PRNatExampleAdd
The function \AgdaFunction{addP} is defined by primitive recursion, which
decomposes the first argument. The $g$-function is just the identity;
the $h$-function composes the successor with inductive result.
The equivalence proof is a
straightforward induction because the structure of the definitions
matches.

There are alternative definitions of primitive recursion where the
zero function takes any number of arguments or where there are
arbitrary constants. It is easy to show that they are equivalent to
the definition that we adopt here.

\section{Primitive recursion for inductive types}
\label{sec:prim-recurs-gener}
\input{latex/PR-CC-ind}

This section introduces PR1-IND, the first order language with inductive
types. The modeling of inductive
types is inspired Harper's textbook \cite{DBLP:books/cu/Ha2016}, but
with two changes. First, Harper's definition is set in a conventional syntax,
whereas ours comes in pointfree style. Second, his definition builds
on polynomial type operators, which we generalize to polynomial
inductive type operators.

We start with defining the type language.
\ccDataTy
Types are indexed by a number $n \in \ANat$ denoting the number of free
type variables in the type. A type is either the empty type, the unit type, a product, a
sum, a variable, or an inductive type. Variables use the
de Bruijn encoding. The body of an inductive type
binds a new type variable for recursive occurrences of the
type. We assume that recursive occurrences are guarded, that is, there
is a sum, product, or inductive type between the binding and the use
of a type variable. Types with free variables are sometimes called
\emph{pretypes}. We use $\ATY$ for closed types.

To define primitive recursion on this type structure in pointfree
style, we have to extend our vocabulary compared to previous attempts.
\ccDataPR
The first compartment defines two families of arrows concerned with categorical structure: the identity arrow at all
types, and type-respecting composition of arrows.
The second compartment names the unique arrow from any type into the
terminal object (the unit type) as well as the unique arrow from the
initial object (the empty type) to any type. 
The third compartment has arrows to introduce and eliminate product types.
The fourth compartment has arrows to introduce and eliminate sum types, which are very obviously dual to
the respective arrows involving products.
The fifth compartment specifies a distributive law of sum types over product types.
The final compartment
defines arrows to introduce {\Afold} and eliminate inductive types
{\AP}. This treatment is still 100\% first order, without higher-order
functions.

Looking at these postulated arrows, we realize that any interpretation
of this syntax must take place in a distributive category
\cite{cockett_1993}, which is  cartesian (part 2 and 3), cocartesian
(part 4), and obeys the distributive law. Subsequent examples show
that each of these requirements (including distributivity) is
necessary to simulate standard definitions of primitive recursion. 
Distributive categories are not uncommon. In fact, every cartesian
closed category with coproducts is also distributive (folklore
according to \cite{https://doi.org/10.48550/arxiv.1406.0961}).

Considering the arrows dealing with inductive types, 
in the definition of {\Afold} and {\AP}, we find that $G :$~\ATy1, a type with a
single type variable. It will be convenient to view $G$ as a functor
that acts on types $T:$~{\ATY} by substitution, i.e., $T \mapsto (G
\Leftarrow T)$. 

Elimination of inductive types is by primitive recursion /
paramorphism. The arrow constructed by {\AP} maps a pair of an element
of an inductive type and an element of another type $U$ to a result type
$T$. The type $U$ corresponds to the non-recursion parameters in the
traditional setting (cf.\ Section~\ref{sec:from-numbers-words}). 
The single parameter $h$ of {\AP} unifies all subordinate
arrows. Thanks to the rich type structure, the dispatch on different
``term constructors'' can be internalized in the calculus. Thus, the
input of $h$ is a pair where the top-level induction for $G$ is
unfolded and applied to a pair of $T$, the result of the inductive
evaluation, and \Aind~$G$, the inductive subterm.

Alternatively, we can equip inductive types with the standard
catamorphism (aka fold operator) at this type:
\ccDataPRF
We omit the details.

To define evaluation, we first define the interpretation of types in Agda.
\ccDataAlg
We reuse as much structure as possible by mapping unit, product, and
sum to the respective Agda types. We interpret all inductive types with a
single generic inductive type \AAlg{G}, which is indexed by its generating
functor $G$.\footnote{Technically speaking, this definition uses
  induction recursion \cite{DBLP:journals/apal/DybjerS03}.}

With this machinery in place, the definition of the evaluation
function is straightforward.
\ccFunEval
The only interesting case is the one for primitive recursion. It is
interpreted by a function taking a pair of \Aind~$G$ and some $U$. The
first component of the argument must evaluate to some \Afold~$x$, so the $x$ corresponds
to the constructor arguments, and the second component $u:U$ is the
extra argument. Now we run the function $h$ essentially on
$x :{} G \Leftarrow \Aind~G$ and $u$, but 
after replacing recursive occurrences of the inductive type by a pair
of the subterm and the recursive call of {\AP}~$h$ on the subterm. We
identify the recursive occurrences by traversing $x$ according to the
structure functor $G$ using the $\Afmap$ function below, which
implements the action of $G$ on functions. 
\ccFunFmap

It turns out that we can map all flavors of primitive recursion from
Section~\ref{sec:from-numbers-words} into primitive recursion in terms
of inductive types. The main difference is that in
Sections~\ref{sec:prim-recurs-words}-\ref{sec:prim-recurs-sort} we
never assumed finiteness of (ranked) alphabets. To successfully map into
inductive types, alphabets must be finite and this requirement
matches the usual mathematical definition of alphabets.

As a simple example, we define the mapping from primitive recursion on
natural numbers into inductive types. We start with the functor $G$
for natural numbers:
\ccDefGNat

The encoding is straightforward, but it reveals the necessity for
distributivity. To start with, it requires an 
encoding of vectors and vector lookup.
\ccFunMkvec
\ccDefNatToInd
The encodings of the constructors apply {\Afold} to the left and right
injection, respectively. Projection and composition are as before. For
the encoding of primitive recursion, we need two helper arrows. One
arrow that implements associativity of the product and another that
implements distributivity of sum over product. While the first one is
definable with the arrows given in the definition of {\APR n}, the
distributivity arrow cannot be composed from the remaining arrows!
\ccFunAssocDist
We conclude with the remark that the language is sufficiently rich to
express the commutative monoidal structure of product types as well as
associativity and commutativity of the sum type (not monoidal as it
lacks the empty type to serve as identity).



\section{Frontier}



, it is less well known that primitive recursive
functions generalize in several dimensions. One dimension generalizes
to words, terms, and many-sorted algebras. Another dimension
generalizes to vector-valued functions aka LOOP-computable
functions. Both of these dimensions are 
subsumed by first-order primitive recursive functions on inductive
types in a bicartesion category (PR1-IND). 
A third dimension adds higher-order functions to obtain System-T from
primitive recursion on natural numbers; analogous systems for
words, terms, and many-sorted algebras are conceivable. At this point, we can subsume
all previous systems in a simply-typed lambda calculus with
inductive types and a primitive recursor (PR-IND). This calculus is
situated in a bicartesian closed category.

We exhibit executable definitions in Agda of several classes of primitive
recursive functions in pointfree style and give embeddings from each
class into the next more general class. We particularly emphasize
PR1-IND and PR-IND.
While the first-order language PR1-IND requires a distributivity axiom
(i.e., the underlying category is distributive), this axiom is no
longer required in PR-IND, because its underlying category has
exponentials.
This finding corresponds to a folklore theorem that every bicartesian
closed category is distributive and we give an elementary proof of
that theorem.
All definitions, embeddings, and proofs are given in Agda.


%%
%% Bibliography
%%

%% Please use bibtex, 

\bibliography{jfprefs}

\end{document}
